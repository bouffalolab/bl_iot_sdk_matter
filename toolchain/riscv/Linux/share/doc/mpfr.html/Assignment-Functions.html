<html lang="en">
<head>
<title>Assignment Functions - GNU MPFR 3.1.4</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="How to install and use GNU MPFR, a library for reliable multiple precision
floating-point arithmetic, version 3.1.4.">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="MPFR-Interface.html#MPFR-Interface" title="MPFR Interface">
<link rel="prev" href="Initialization-Functions.html#Initialization-Functions" title="Initialization Functions">
<link rel="next" href="Combined-Initialization-and-Assignment-Functions.html#Combined-Initialization-and-Assignment-Functions" title="Combined Initialization and Assignment Functions">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
This manual documents how to install and use the Multiple Precision
Floating-Point Reliable Library, version 3.1.4.

Copyright 1991, 1993-2016 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant Sections,
with no Front-Cover Texts, and with no Back-Cover Texts.  A copy of the
license is included in *note GNU Free Documentation License::.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Assignment-Functions"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Combined-Initialization-and-Assignment-Functions.html#Combined-Initialization-and-Assignment-Functions">Combined Initialization and Assignment Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Initialization-Functions.html#Initialization-Functions">Initialization Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="MPFR-Interface.html#MPFR-Interface">MPFR Interface</a>
<hr>
</div>

<!-- node-name,  next,  previous,  up -->
   <p><a name="index-Assignment-functions-39"></a>

<h3 class="section">5.2 Assignment Functions</h3>

<p>These functions assign new values to already initialized floats
(see <a href="Initialization-Functions.html#Initialization-Functions">Initialization Functions</a>).

<div class="defun">
&mdash; Function: int <b>mpfr_set</b> (<var>mpfr_t rop, mpfr_t op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset-40"></a></var><br>
&mdash; Function: int <b>mpfr_set_ui</b> (<var>mpfr_t rop, unsigned long int op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fui-41"></a></var><br>
&mdash; Function: int <b>mpfr_set_si</b> (<var>mpfr_t rop, long int op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fsi-42"></a></var><br>
&mdash; Function: int <b>mpfr_set_uj</b> (<var>mpfr_t rop, uintmax_t op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fuj-43"></a></var><br>
&mdash; Function: int <b>mpfr_set_sj</b> (<var>mpfr_t rop, intmax_t op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fsj-44"></a></var><br>
&mdash; Function: int <b>mpfr_set_flt</b> (<var>mpfr_t rop, float op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fflt-45"></a></var><br>
&mdash; Function: int <b>mpfr_set_d</b> (<var>mpfr_t rop, double op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fd-46"></a></var><br>
&mdash; Function: int <b>mpfr_set_ld</b> (<var>mpfr_t rop, long double op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fld-47"></a></var><br>
&mdash; Function: int <b>mpfr_set_decimal64</b> (<var>mpfr_t rop, _Decimal64 op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fdecimal64-48"></a></var><br>
&mdash; Function: int <b>mpfr_set_z</b> (<var>mpfr_t rop, mpz_t op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fz-49"></a></var><br>
&mdash; Function: int <b>mpfr_set_q</b> (<var>mpfr_t rop, mpq_t op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fq-50"></a></var><br>
&mdash; Function: int <b>mpfr_set_f</b> (<var>mpfr_t rop, mpf_t op, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005ff-51"></a></var><br>
<blockquote><p>Set the value of <var>rop</var> from <var>op</var>, rounded
toward the given direction <var>rnd</var>. 
Note that the input 0 is converted to +0 by <code>mpfr_set_ui</code>,
<code>mpfr_set_si</code>, <code>mpfr_set_uj</code>, <code>mpfr_set_sj</code>,
<code>mpfr_set_z</code>, <code>mpfr_set_q</code> and
<code>mpfr_set_f</code>, regardless of the rounding mode. 
If the system does not support the IEEE 754 standard,
<code>mpfr_set_flt</code>, <code>mpfr_set_d</code>, <code>mpfr_set_ld</code> and
<code>mpfr_set_decimal64</code> might not preserve the signed zeros. 
The <code>mpfr_set_decimal64</code> function is built only with the configure
option &lsquo;<samp><span class="samp">--enable-decimal-float</span></samp>&rsquo;, which also requires
&lsquo;<samp><span class="samp">--with-gmp-build</span></samp>&rsquo;, and when the compiler or
system provides the &lsquo;<samp><span class="samp">_Decimal64</span></samp>&rsquo; data type
(recent versions of GCC support this data type);
to use <code>mpfr_set_decimal64</code>, one should define the macro
<code>MPFR_WANT_DECIMAL_FLOATS</code> before including <samp><span class="file">mpfr.h</span></samp>. 
<!-- GCC 4.2.0 required to be configured with -enable-decimal-float -->
<!-- but GCC 4.4.3 seems to have decimal support by default -->
<code>mpfr_set_q</code> might fail if the numerator (or the
denominator) can not be represented as a <code>mpfr_t</code>.

        <p>Note: If you want to store a floating-point constant to a <code>mpfr_t</code>,
you should use <code>mpfr_set_str</code> (or one of the MPFR constant functions,
such as <code>mpfr_const_pi</code> for Pi) instead of
<code>mpfr_set_flt</code>, <code>mpfr_set_d</code>,
<code>mpfr_set_ld</code> or <code>mpfr_set_decimal64</code>. 
Otherwise the floating-point constant will be first
converted into a reduced-precision (e.g., 53-bit) binary
(or decimal, for <code>mpfr_set_decimal64</code>) number before
MPFR can work with it. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_set_ui_2exp</b> (<var>mpfr_t rop, unsigned long int op, mpfr_exp_t e, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fui_005f2exp-52"></a></var><br>
&mdash; Function: int <b>mpfr_set_si_2exp</b> (<var>mpfr_t rop, long int op, mpfr_exp_t e, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fsi_005f2exp-53"></a></var><br>
&mdash; Function: int <b>mpfr_set_uj_2exp</b> (<var>mpfr_t rop, uintmax_t op, intmax_t e, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fuj_005f2exp-54"></a></var><br>
&mdash; Function: int <b>mpfr_set_sj_2exp</b> (<var>mpfr_t rop, intmax_t op, intmax_t e, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fsj_005f2exp-55"></a></var><br>
&mdash; Function: int <b>mpfr_set_z_2exp</b> (<var>mpfr_t rop, mpz_t op, mpfr_exp_t e, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fz_005f2exp-56"></a></var><br>
<blockquote><p>Set the value of <var>rop</var> from <var>op</var> multiplied by
two to the power <var>e</var>, rounded toward the given direction <var>rnd</var>. 
Note that the input 0 is converted to +0. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_set_str</b> (<var>mpfr_t rop, const char *s, int base, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fset_005fstr-57"></a></var><br>
<blockquote><p>Set <var>rop</var> to the value of the string <var>s</var> in base <var>base</var>,
rounded in the direction <var>rnd</var>. 
See the documentation of <code>mpfr_strtofr</code> for a detailed description
of the valid string formats. 
Contrary to <code>mpfr_strtofr</code>, <code>mpfr_set_str</code> requires the
<em>whole</em> string to represent a valid floating-point number. 
<!-- Additionally, special values -->
<!-- @code{@@NaN@@}, @code{@@Inf@@}, @code{+@@Inf@@} and @code{-@@Inf@@}, -->
<!-- all case insensitive, without leading whitespace and possibly followed by -->
<!-- other characters, are accepted too (it may change). -->

        <p>The meaning of the return value differs from other MPFR functions:
it is 0 if the entire string up to the final null character
is a valid number in base <var>base</var>; otherwise it is &minus;1, and
<var>rop</var> may have changed (users interested in the <a href="ternary-value.html#ternary-value">ternary value</a>
should use <code>mpfr_strtofr</code> instead).

        <p>Note: it is preferable to use <code>mpfr_strtofr</code> if one wants to distinguish
between an infinite <var>rop</var> value coming from an infinite <var>s</var> or from
an overflow. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: int <b>mpfr_strtofr</b> (<var>mpfr_t rop, const char *nptr, char **endptr, int base, mpfr_rnd_t rnd</var>)<var><a name="index-mpfr_005fstrtofr-58"></a></var><br>
<blockquote><p>Read a floating-point number from a string <var>nptr</var> in base <var>base</var>,
rounded in the direction <var>rnd</var>; <var>base</var> must be either 0 (to
detect the base, as described below) or a number from 2 to 62 (otherwise
the behavior is undefined). If <var>nptr</var> starts with valid data, the
result is stored in <var>rop</var> and <code>*</code><var>endptr</var> points to the
character just after the valid data (if <var>endptr</var> is not a null pointer);
otherwise <var>rop</var> is set to zero (for consistency with <code>strtod</code>)
and the value of <var>nptr</var> is stored
in the location referenced by <var>endptr</var> (if <var>endptr</var> is not a null
pointer). The usual ternary value is returned.

        <p>Parsing follows the standard C <code>strtod</code> function with some extensions. 
After optional leading whitespace, one has a subject sequence consisting of an
optional sign (<code>+</code> or <code>-</code>), and either numeric data or special
data. The subject sequence is defined as the longest initial subsequence of
the input string, starting with the first non-whitespace character, that is of
the expected form.

        <p>The form of numeric data is a non-empty sequence of significand digits with an
optional decimal point, and an optional exponent consisting of an exponent
prefix followed by an optional sign and a non-empty sequence of decimal
digits. A significand digit is either a decimal digit or a Latin letter (62
possible characters), with <code>A</code> = 10, <code>B</code> = 11, <small class="dots">...</small>, <code>Z</code> =
35; case is ignored in bases less or equal to 36, in bases larger than 36,
<code>a</code> = 36, <code>b</code> = 37, <small class="dots">...</small>, <code>z</code> = 61. 
The value of a
significand digit must be strictly less than the base.  The decimal point can
be either the one defined by the current locale or the period (the first one
is accepted for consistency with the C standard and the practice, the second
one is accepted to allow the programmer to provide MPFR numbers from strings
in a way that does not depend on the current locale). 
The exponent prefix can be <code>e</code> or <code>E</code> for bases up to 10, or
<code>@</code> in any base; it indicates a multiplication by a power of the
base. In bases 2 and 16, the exponent prefix can also be <code>p</code> or <code>P</code>,
in which case the exponent, called <em>binary exponent</em>, indicates a
multiplication by a power of 2 instead of the base (there is a difference
only for base 16); in base 16 for example <code>1p2</code> represents 4 whereas
<code>1@2</code> represents 256. The value of an exponent is always written in
base 10.

        <p>If the argument <var>base</var> is 0, then the base is automatically detected
as follows. If the significand starts with <code>0b</code> or <code>0B</code>, base 2
is assumed. If the significand starts with <code>0x</code> or <code>0X</code>, base 16
is assumed. Otherwise base 10 is assumed.

        <p>Note: The exponent (if present)
must contain at least a digit. Otherwise the possible
exponent prefix and sign are not part of the number (which ends with the
significand). Similarly, if <code>0b</code>, <code>0B</code>, <code>0x</code> or <code>0X</code>
is not followed by a binary/hexadecimal digit, then the subject sequence
stops at the character <code>0</code>, thus 0 is read.

        <p>Special data (for infinities and NaN) can be <code>@inf@</code> or
<code>@nan@(n-char-sequence-opt)</code>, and if <var>base</var> &lt;= 16,
it can also be <code>infinity</code>, <code>inf</code>, <code>nan</code> or
<code>nan(n-char-sequence-opt)</code>, all case insensitive. 
A <code>n-char-sequence-opt</code> is a possibly empty string containing only digits,
Latin letters and the underscore (0, 1, 2, <small class="dots">...</small>, 9, a, b, <small class="dots">...</small>, z,
A, B, <small class="dots">...</small>, Z, _). Note: one has an optional sign for all data, even
NaN. 
For example, <code>-@nAn@(This_Is_Not_17)</code> is a valid representation for NaN
in base 17.

        </blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_set_nan</b> (<var>mpfr_t x</var>)<var><a name="index-mpfr_005fset_005fnan-59"></a></var><br>
&mdash; Function: void <b>mpfr_set_inf</b> (<var>mpfr_t x, int sign</var>)<var><a name="index-mpfr_005fset_005finf-60"></a></var><br>
&mdash; Function: void <b>mpfr_set_zero</b> (<var>mpfr_t x, int sign</var>)<var><a name="index-mpfr_005fset_005fzero-61"></a></var><br>
<blockquote><p>Set the variable <var>x</var> to NaN (Not-a-Number), infinity or zero respectively. 
In <code>mpfr_set_inf</code> or <code>mpfr_set_zero</code>, <var>x</var> is set to plus
infinity or plus zero iff <var>sign</var> is nonnegative;
in <code>mpfr_set_nan</code>, the sign bit of the result is unspecified. 
</p></blockquote></div>

<div class="defun">
&mdash; Function: void <b>mpfr_swap</b> (<var>mpfr_t x, mpfr_t y</var>)<var><a name="index-mpfr_005fswap-62"></a></var><br>
<blockquote><p>Swap the structures pointed to by <var>x</var> and <var>y</var>. In particular,
the values are exchanged without rounding (this may be different from
three <code>mpfr_set</code> calls using a third auxiliary variable).

        <p>Warning! Since the precisions are exchanged, this will affect future
assignments. Moreover, since the significand pointers are also exchanged,
you must not use this function if the allocation method used for <var>x</var>
and/or <var>y</var> does not permit it. This is the case when <var>x</var> and/or
<var>y</var> were declared and initialized with <code>MPFR_DECL_INIT</code>, and
possibly with <code>mpfr_custom_init_set</code> (see <a href="Custom-Interface.html#Custom-Interface">Custom Interface</a>). 
</p></blockquote></div>

   </body></html>

